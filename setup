#!/usr/local/bin/python3.11


# This script should take a user from the bsdinstall (which sets up a minimal 
# operating system that is not ready to be used as a personal computer in the 
# modern day) to an MVP desktop environment.
#
# There is no login manager. After the user logs in via tty, `startx` is ran 
# bringing them to i3.
# 
# Currently runs on just 400 MB of ram. Compare to the original value of 6.5 GB 
# of ram "wasted" on Wired Memory.

import os
import sys
from pprint import pprint

global config

RC_CONF     = "/etc/rc.conf"
SYSCTL_CONF = "/etc/sysctl.conf"
FSTAB       = "/etc/fstab"

# The desired options
class Config:
    graphics_driver: str  = "intel"
    reduce_memory  : bool = False
    mount_proc     : bool = False
    enable_exfatfs : bool = False
    setup_ports    : bool = False
    linux_enable   : bool = False
    add_skriptlins_to_path     : bool = False

    def debug(self):
        pprint(self.__dict__)

config = Config()
def main():
    User.ensure_super_user()
    todo("check if user has internet. If not, set it up for them.")

    Prompt.run()
    System.install_packages()
    Configure.run()



    System.reboot()


class Prompt:

    @staticmethod
    def run() -> None:
        global config

        config.graphics_driver = Prompt.graphics_driver()
        config.reduce_memory   = Prompt.reduce_memory()
        config.mount_proc      = Prompt.mount_proc()
        config.setup_ports     = Prompt.setup_ports()
        config.linux_enable    = Prompt.linux_enable()
        config.add_skriptlins_to_path = Prompt.add_skriptlins_to_path()
        todo("ask user if they would like to enable automount.")

        print()

    @staticmethod
    def add_skriptlins_to_path():
        prompt = "Would you like to add the 'skriptlins' directory to your path?"
        return Prompt.yes_no_loop(prompt)

    @staticmethod
    def linux_enable():
        prompt = "Would you like to enable Linux compatability?"
        return Prompt.yes_no_loop(prompt)

    @staticmethod
    def graphics_driver() -> str:
        prompt = "Choose a graphics driver."
        return Prompt.choice_loop(prompt, 
                               "[Intel|amd|nvidia]", 
                               ["intel", "amd", "nvidia", ""], 
                               "intel")
    @staticmethod
    def setup_ports():
        prompt = "Would you like to setup ports?"
        return Prompt.yes_no_loop(prompt)

    @staticmethod
    def mount_proc() -> bool:
        prompt = "Would you mount 'proc'? This is used by some " \
              "Linux applications such as Gnome and KDE."
        return Prompt.yes_no_loop(prompt)

    @staticmethod
    def reduce_memory() -> bool:
        prompt = "Would you like to reduce the amount of memory FreeBSD " \
              "Allocates by default?"
        return Prompt.yes_no_loop(prompt, "n")

    # ------ Helpers
    @staticmethod
    def yes_no_loop(prompt: str, default: str = "y") -> bool:
        box = "[Y/n]"
        if default == "n": box = "[y/N]"
        prompt = f"{prompt} {box}: "
        return bool(Prompt.loop(prompt, ["y", "n", ""], default))

    @staticmethod
    def choice_loop(prompt: str, box: str, choices: list[str], default: str) -> str:
        prompt = f"{prompt} {box}: "
        return str(Prompt.loop(prompt, choices, default))

    @staticmethod
    def loop(prompt: str, valid_answers: list[str], default_answer: str) -> bool | str:
        while True:
            choice: str = input(prompt).lower()
            if choice == "": choice = default_answer

            if choice not in valid_answers:
                err_msg = f"Please choose one of the following: {valid_answers}."
                System.notify("p", err_msg)
                continue

            if choice == "y"  : return True
            elif choice == "n": return False
            elif choice == "" : return default_answer

            return choice


# The code to actually configure the user's
# desired options.
class Configure:

    @staticmethod
    def run() -> None:
        global config
        System.notify("c", "Configuring the system based on user inputs.")

        if config.graphics_driver        : Configure.graphics_driver()
        if config.reduce_memory          : Configure.reduce_memory()
        if config.mount_proc             : Configure.mount_proc()
        if config.setup_ports            : Configure.setup_ports()
        if config.add_skriptlins_to_path : Configure.add_skriptlins_to_path()

        todo("setup mount.exfat for mounting vfat usb sticks.")
        todo("enable automount.")

        todo("enable linux compatability: chapter 12.")
        # Config Files
        todo(".config files: Rofi, i3")
        todo("setup i3 to use better applications. Rofi/Firefox/Terminal")

        # To be able to watch youtube videos for example.
        todo("enable pulseaudio.")

        Configure.start_x_after_login()
        Configure.xinitrc()
            


        return None

    
    @staticmethod
    def graphics_driver() -> None:
        global config
        INTEL_MODULE: str = "i915kms"

        graphics_driver = config.graphics_driver
        System.notify("c", f"Configuring video driver for '{graphics_driver}'.")

        
        value: list[str] | None = Conf.get_value(RC_CONF, "kld_list")

        msg = f"Skipping: Not enabling '{INTEL_MODULE}' kernel module: 'load_list+=\"{INTEL_MODULE}\"' already in '/etc/rc.conf'."
        if value:
            System.notify("c", msg)
            return

        System.kdl_list_add(INTEL_MODULE)
        return None

    @staticmethod
    def reduce_memory() -> None: 
        global config

        vfs_maxbufspace: str = "vfs.maxbufspace"
        msg = f"Skipping: Not reducing memory. '{vfs_maxbufspace}' is already configured."
        if Conf.key_exists(SYSCTL_CONF, vfs_maxbufspace):
            System.notify("c", msg)
            return None

        System.run("./skriptlins/tune-memory-wired")
        return None

    @staticmethod
    def mount_proc() -> None:
        line = "proc            /proc           procfs  rw      0       0"
        cmd  = f"echo \"{line}\" >> {FSTAB}"

        if Conf.contains_exact_line(FSTAB, line):
            System.notify("c", f"Skipping: Not mounting proc. A proc entry already exists in '{FSTAB}'.")
            return None

        System.run(f"{cmd}")
        return None

    @staticmethod
    def enable_exfatfs() -> None:
        global config
        todo("configure exfat support.")
        return None

    @staticmethod
    def linux_compatability():
        global config
        todo("configure linux compatability.")
        return None

    @staticmethod
    def setup_ports() -> bool:

        ports_dir = "/usr/ports"
        if os.path.exists(ports_dir):
            System.notify("c", f"Skipping: Not setting up ports. Directory already exists: '{ports_dir}'.")
            return False

        System.run("git clone https://git.freebsd.org/ports.git /usr/ports")
        todo("install a port manager.")
        return True

    @staticmethod
    def add_skriptlins_to_path():
        skriptlins            = "skriptlins"
        skriptlins_source_dir = "./{skriptlins}"

        from glob import glob
        skriptlins_source: list[str] = glob(f"{skriptlins_source_dir}/*")

        #skriptlins_source = f"./{skriptlins}"
        # Only command I know that will get you the name of the user who
        # ran `doas` is `users`.
        user_home: str = User.get_home()
        skriptlins_dst    = f"{user_home}/.local/bin/{skriptlins}"

        bashrc_path = f"{user_home}/.bashrc"


        def contains_skriptlin_export(file_path: str, cmd: str) -> bool:
            return Conf.contains_exact_line(file_path, cmd)

        def copy_skriptlins_to_local_bin():
            if os.path.exists(skriptlins_dst):
                System.notify("c", f"Skipping: Not copying skriptlins over to '{skriptlins_dst}'. Directory already exists.")
                return

            System.run(f"cp -R {skriptlins_source} {skriptlins_dst}")
            return

        def __add_skriptlins_to_path():
            PATH: list[str] = os.environ["PATH"]
            CMD: str = f"echo export PATH=\$PATH:{skriptlins_dst} >> {bashrc_path}"
            # Geez...
            export_cmd: str = " ".join(CMD.split()[1:3]).replace("\\", "")

            if contains_skriptlin_export(bashrc_path, export_cmd):
                System.notify("c", f"Skipping: Not exporting skriptlins path: '{export_cmd}' is already in '{bashrc_path}'.")
                return

            # Took me a second to figure out why the whole path was being piped
            # to the .bashrc.
            System.run(CMD)
            return


        copy_skriptlins_to_local_bin()
        __add_skriptlins_to_path()
        return

    @staticmethod
    def start_x_after_login():
        home_dir = User.get_home()
        profile = f"{home_dir}/.profile"

        System.notify("c", f"Configuring '{profile}' to start up Xor immediately after you log in.")

        if Conf.contains_exact_line(profile, "startx"):
            System.notify("c", "Skipping: Not configuring the system to start Xorg after logging in: Already configured.")
            return None

        script = """
    if [ -z "$DISPLAY" ] && [ "$(tty)" = "/dev/ttyv0" ];then
        startx
    fi
    """
        System.file_append(profile, script)
        
        #System.print("RAN: cat ./snippets/{script_name} ./skriptlins/xorg-start-after-login")
        return None

    @staticmethod
    def xinitrc() -> None:
        xinitrc_personal =  f"{User.get_home()}/.xinitrc"

        # NOTE: Here's I'm defining custom keyboard options. 
        # TODO(tyler): This could be a global variable that is easier to configure.

        swap_caps_with_escape = "setxkbmap -option caps:swapescape"
        exec_i3 = "exec i3"

        if Conf.contains_exact_line(xinitrc_personal, swap_caps_with_escape):
            System.notify("c", f"Skipping: Not adding '{swap_caps_with_escape}' to ~/.xinitrc: Already configured.")
        else:
            System.file_append(xinitrc_personal, "setxkbmap -option caps:swapescape")

        if Conf.contains_exact_line(xinitrc_personal, exec_i3):
            System.notify("c", f"Skipping: Not adding '{exec_i3} to ~/.xinitrc: Already configured.")
        else:
            System.file_append(xinitrc_personal, exec_i3, newline=False)


class Conf:
    @staticmethod
    def kld_module_exists(kld_module: str) -> bool:
        kld_list: list[str] | None = Conf.get_value(RC_CONF, "kld_list")
        if not kld_list:
            return False

        return kld_module in kld_list

    @staticmethod
    def key_exists(conf_path: str, needle_key) -> bool:
        def fn(haystack_key: str):
            return needle_key == haystack_key

        return Conf.search(conf_path, fn)[0]

    @staticmethod
    def get_value(conf_path: str, needle_key: str) -> list[str] | None:
        def fn(haystack_key: str):
            return needle_key == haystack_key

        return Conf.search(conf_path, fn)[1]


    @staticmethod
    def search(conf_path: str, condition_fn) -> tuple[bool, list[str] | None]:
        conf: list[str] = System.read_file(conf_path)

        for line in conf:
            conf_sp: list[str] = line.split("=")
            if len(conf_sp) != 2:
                continue
            haystack_key, value = conf_sp
            if condition_fn(haystack_key):
                return (True, Conf.value_from(value))

        return (False, None)

    @staticmethod
    def contains_exact_line(file_path: str, line: str) -> bool:
        file_contents: list[str] = System.read_file(file_path)
        for _line in file_contents:
            if _line.strip() == line:
                return True
        return False


    @staticmethod
    def value_from(raw_string: str) -> list[str]:
        return [ value.replace("\"", "") for value in raw_string.split(" ") ]

class User:

    @staticmethod
    def ensure_super_user() -> None:
        if User.is_super_user() is False:
            err_msg = "This script must be ran as a super user. "\
                      "Please run with either "                  \
                      "`doas` or `sudo`."
            System.error(err_msg)
        return None

    @staticmethod
    def is_super_user() -> bool:
        return int(os.getuid()) == 0

    @staticmethod
    def get_name() -> str:
        return os.popen("users").read().strip()

    @staticmethod
    def get_home() -> str:
        user: str = User.get_name()
        return f"/home/{user}"


flush = sys.stdout.flush

# Code section to get/set/display system information/commands
class System:
    @staticmethod
    # TODO(tyler): Would be nice if this returned (exit_code, string)
    def run(cmd) -> None:
        print(cmd)
        os.system(cmd)
        return None

    @staticmethod
    def error(msg) -> None:
        print(msg)
        exit(1)

    @staticmethod
    def reboot():
        System.print("FAKING: reboot")
        #System.run("reboot)
        #os.system("reboot")

    @staticmethod
    def install_packages():
        todo("enable pkg install <required-packages>")
        System.print(r"pkg install --dry-run --yes $(cat packages.txt | tr '\n' ' ')")

    @staticmethod
    def print(msg):
        print(msg)
        flush()

    @staticmethod
    def notify(stage: str, msg: str) -> None:
        philter: dict[str, str] = {
                "c": "configure",
                "p": "prompt",
                "t": "TODO"
        }
        assert stage in philter.keys()

        expanded_stage: str = philter[stage]
        System.print(f"[{expanded_stage}] {msg}")

    @staticmethod
    def read_file(path: str) -> list[str]:
        f = open(path, "r")
        c = f.read()
        f.close()

        return c.split("\n")

    @staticmethod
    def kdl_list_add(val: str) -> None:
        System.run("sysrc kdl_load+={val}")

    @staticmethod
    def file_append(file_path: str, to_append: str, newline: bool = True) -> None:
        System.notify("c", f"Appending to '{file_path}':\n{to_append}")
        assert os.path.exists(file_path)

        f = open(file_path, "a")
        if newline: f.write(f"\n{to_append}")
        else      : f.write(to_append)
        f.close()

        return None
    

def todo(msg):
    System.notify("t", msg)


if __name__ == "__main__":
    #Configure.reduce_memory()
    #System.file_append("hello.txt", "hello")
    main()
